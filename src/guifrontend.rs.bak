use bevy::{color::palettes::css::GOLD, diagnostic::{DiagnosticsStore, 
    FrameTimeDiagnosticsPlugin}, input::keyboard::KeyboardInput, prelude::*, render::texture::TextureFormatPixelInfo};

use bevy::{
        a11y::{
            accesskit::{NodeBuilder, Role},
            AccessibilityNode,
        },
        color::palettes::basic::LIME,
        input::mouse::{MouseScrollUnit, MouseWheel},
        prelude::*,
        winit::WinitSettings,
    };

use std::collections::HashSet;
use std::{
    fs::File,
    io,
    io::Write,
    path::{Path, PathBuf},
    process::{exit, ExitStatus},
};

use colored::Colorize;
use console::Emoji;
use dialoguer::theme::ColorfulTheme;
use dialoguer::{FuzzySelect, Input, Select};
use indicatif::{ProgressBar, ProgressStyle};
use is_executable::IsExecutable;
use std::ffi::{OsStr, OsString};
use crate::config;
use crate::config::ResolvedConfig;
use crate::indexer::{IndexError, IndexedTable, Progress};
use crate::patcher::LineEndingsResult::{NoChanges, Unified};
use crate::patcher::{patch_vbs_file, unify_line_endings_vbs_file};
use crate::{
    indexer, info_diff, info_edit, info_gather, open_editor, run_diff, script_diff,
    vpx::{extractvbs, vbs_path_for, ExtractResult},
    DiffColor, ProgressBarProgress,
};


#[derive(Component, Debug)]
struct Position {
    x:i32,
    y:i32,
}

use vleue_kinetoscope::{AnimatedImagePlugin,AnimatedImageBundle,AnimatedImageController};


const LAUNCH: Emoji = Emoji("ðŸš€", "[launch]");
const CRASH: Emoji = Emoji("ðŸ’¥", "[crash]");

const SEARCH: &str = "> Search";
const RECENT: &str = "> Recent";
const SEARCH_INDEX: usize = 0;
const RECENT_INDEX: usize = 1;

#[derive(Component, Clone, Copy, PartialEq, Eq)]
enum Image {
    Apng,
    Gif,
    Webp,
    png,
    jpg,
    }

impl std::fmt::Display for Image {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Image::Gif => write!(f, "GIF"),
            Image::Webp => write!(f, "WebP"),
            Image::Apng => write!(f, "Apng"),
            Image::png => write!(f, "png"),
            Image::jpg => write!(f, "jpg"),

        }
    }
}

fn create_wheel(mut commands: Commands,asset_server: Res<AssetServer>, window: Query<&Window>)
{
    let window_width = window.single().width() / 2.0;
    let (_config_path,loaded_config) = config::load_config().unwrap().unwrap();
    let vpx_files_with_tableinfo = frontend_index(&loaded_config, true, vec![]); 
    let vpx_files_with_tableinfo1 = frontend_index(&loaded_config, true, vec![]).unwrap(); 

    let roms = indexer::find_roms(loaded_config.global_pinmame_rom_folder());
    let roms1 = roms.unwrap();
    let tables: Vec<String> = vpx_files_with_tableinfo.unwrap()
    .iter()
    .map(|indexed| display_table_line_full(indexed, &roms1))
    .collect();
//
    let  tables_len= tables.len();
    let mut counter=0;
    while counter < tables_len
        {
        let info = vpx_files_with_tableinfo1
        .get(counter)
        .unwrap()
        .clone();

         println!("{:?}",info.wheel_path);
//        let mut stem:OsString = info.path.file_stem().unwrap().to_owned().into();
        //let ext =".png";
//        stem.push(".png");
//        let mut tables_folder:OsString = Some(&config.tables_folder).unwrap().into();
//            tables_folder = tables_folder;
//        tables_folder.push("/Wheels/");
//        tables_folder.push(&stem);
            
  //      if Path::new(&tables_folder).exists() {println!("{:?}", &stem);}

    //let config = loaded_config.as_ref().map(|c| &c.1);

    //for {
        commands.spawn(Position {x:0, y:0});
            for (i, (kind, file)) in [(Image::Webp, "/usr/tables/Media/giphy.webp")]
            .into_iter()
            .enumerate()
             {
              {
            commands.spawn((
                AnimatedImageBundle {
                    animated_image: asset_server.load(file),
                    transform: Transform::from_xyz(
                        -window_width * ((-1.0 as f32).powi(i as i32)) / 2.0,
                      //  -75.0,
                        00.0,
                        0.0,
                    ),
                    ..default()
                },
                kind,
            )
            
        );
          
        counter += 1; };
    }
}
}

fn update_position(mut query: Query<&mut Position>) {
    for mut position in query.iter_mut()
    { position.x += 10;};
}

fn print_position(query: Query<(Entity, &Position)>) {
    for (entity, position) in query.iter() {
       () // info!("Entity {:?} is at position {:?},",entity, position);
    }
}

#[derive(Component)]
struct FpsText;

// A unit struct to help identify the color-changing Text component
#[derive(Component)]
struct ColorText;

#[derive(Component, Default)]
struct ScrollingList {
    position: f32,
}

fn mouse_scroll(
    mut mouse_wheel_events: EventReader<MouseWheel>,
    mut query_list: Query<(&mut ScrollingList, &mut Style, &Parent, &Node)>,
    query_node: Query<&Node>,
) {
    for mouse_wheel_event in mouse_wheel_events.read() {
        for (mut scrolling_list, mut style, parent, list_node) in &mut query_list {
            let items_height = list_node.size().y;
            let container_height = query_node.get(parent.get()).unwrap().size().y;

            let max_scroll = (items_height - container_height).max(0.);

            let dy = match mouse_wheel_event.unit {
                MouseScrollUnit::Line => mouse_wheel_event.y * 20.,
                MouseScrollUnit::Pixel => mouse_wheel_event.y,
            };

            scrolling_list.position += dy;
            scrolling_list.position = scrolling_list.position.clamp(-max_scroll, 0.);
            style.top = Val::Px(scrolling_list.position);
        }
    }
}


enum TableOption {
    Launch,
    LaunchFullscreen,
    LaunchWindowed,
    ForceReload,
    InfoShow,
    InfoEdit,
    InfoDiff,
    ExtractVBS,
    EditVBS,
    PatchVBS,
    UnifyLineEndings,
    ShowVBSDiff,
    CreateVBSPatch,
    // ClearNVRAM,
}

impl TableOption {
    const ALL: [TableOption; 13] = [
        TableOption::Launch,
        TableOption::LaunchFullscreen,
        TableOption::LaunchWindowed,
        TableOption::ForceReload,
        TableOption::InfoShow,
        TableOption::InfoEdit,
        TableOption::InfoDiff,
        TableOption::ExtractVBS,
        TableOption::EditVBS,
        TableOption::PatchVBS,
        TableOption::UnifyLineEndings,
        TableOption::ShowVBSDiff,
        TableOption::CreateVBSPatch,
        // TableOption::ClearNVRAM,
    ];

    fn from_index(index: usize) -> Option<TableOption> {
        match index {
            0 => Some(TableOption::Launch),
            1 => Some(TableOption::LaunchFullscreen),
            2 => Some(TableOption::LaunchWindowed),
            3 => Some(TableOption::ForceReload),
            4 => Some(TableOption::InfoShow),
            5 => Some(TableOption::InfoEdit),
            6 => Some(TableOption::InfoDiff),
            7 => Some(TableOption::ExtractVBS),
            8 => Some(TableOption::EditVBS),
            9 => Some(TableOption::PatchVBS),
            10 => Some(TableOption::UnifyLineEndings),
            11 => Some(TableOption::ShowVBSDiff),
            12 => Some(TableOption::CreateVBSPatch),
            // 13 => Some(TableOption::ClearNVRAM),
            _ => None,
        }
    }

    fn display(&self) -> String {
        match self {
            TableOption::Launch => "Launch".to_string(),
            TableOption::LaunchFullscreen => "Launch fullscreen".to_string(),
            TableOption::LaunchWindowed => "Launch windowed".to_string(),
            TableOption::ForceReload => "Force reload".to_string(),
            TableOption::InfoShow => "Info > Show".to_string(),
            TableOption::InfoEdit => "Info > Edit".to_string(),
            TableOption::InfoDiff => "Info > Diff".to_string(),
            TableOption::ExtractVBS => "VBScript > Extract".to_string(),
            TableOption::EditVBS => "VBScript > Edit".to_string(),
            TableOption::PatchVBS => "VBScript > Patch typical standalone issues".to_string(),
            TableOption::UnifyLineEndings => "VBScript > Unify line endings".to_string(),
            TableOption::ShowVBSDiff => "VBScript > Diff".to_string(),
            TableOption::CreateVBSPatch => "VBScript > Create patch file".to_string(),
            // TableOption::ClearNVRAM => "Clear NVRAM".to_string(),
        }
    }
}

pub fn frontend_index(
    resolved_config: &ResolvedConfig,
    recursive: bool,
    force_reindex: Vec<PathBuf>,
) -> Result<Vec<IndexedTable>, IndexError> {
    let pb = ProgressBar::hidden();
    pb.set_style(
        ProgressStyle::with_template(
            "{spinner:.green} [{bar:.cyan/blue}] {pos}/{human_len} ({eta})",
        )
        .unwrap(),
    );
    let progress = ProgressBarProgress::new(pb);
    let index = indexer::index_folder(
        recursive,
        &resolved_config.tables_folder,
        &resolved_config.tables_index_path,
        &progress,
        force_reindex,
    );
    progress.finish_and_clear();
    let index = index?;

    let mut tables: Vec<IndexedTable> = index.tables();
    tables.sort_by_key(|indexed| display_table_line(indexed).to_lowercase());
    Ok(tables)
}

fn keyboard_input_system(input: Res<ButtonInput<KeyCode>>) {
   // let shift = input.any_pressed([KeyCode::ShiftLeft, KeyCode::ShiftRight]);
   // let ctrl = input.any_pressed([KeyCode::ControlLeft, KeyCode::ControlRight]);

   for key in input.get_pressed().collect::<Vec<_>>(){
        match key {
            bevy::prelude::KeyCode::ShiftLeft => println!("Left shift"),
            bevy::prelude::KeyCode::ShiftRight => println!("Right shift"),
            _ => (),
        }
    }
    
  //      println!("keyboard: {:?}", input.get_pressed().collect::<Vec<_>>());
    
   // if ctrl && shift && input.just_pressed(KeyCode::KeyA) {
     //   info!("Just pressed Ctrl + Shift + A!"); }
           
}

pub fn guifrontend(
    config: &ResolvedConfig,
    mut vpx_files_with_tableinfo: Vec<IndexedTable>,
    roms: &HashSet<String>,
    vpinball_executable: &Path,
) {
    let tables: Vec<String> = vpx_files_with_tableinfo
    .iter()
    .map(|indexed| display_table_line_full(indexed, roms))
    .collect();

        App::new()
            .add_plugins((DefaultPlugins, FrameTimeDiagnosticsPlugin))
            .add_plugins(AnimatedImagePlugin)
            .add_systems(Update, keyboard_input_system)
          //  .add_systems(Startup, setup)
            .add_systems(Startup, create_wheel)
            .add_systems(Update, (text_update_system, text_color_system))
            .add_systems(Update,(update_position, print_position))
            .run();
           
        
//    let mut main_selection_opt = None;
   // loop {
    
          //  let selected = FuzzySelect::with_theme(&ColorfulTheme::default())
          //  .with_prompt("Search a table:")
          //  .items(&tables)
          // .interact_opt()
          // .unwrap();
        
    /*     let  tables_len= tables.len();
        let mut counter=0;
        while counter < tables_len
            {
            let info = vpx_files_with_tableinfo
            .get(counter)
            .unwrap()
            .clone();
// get filename and add .png to the extension
            let mut stem:OsString = info.path.file_stem().unwrap().to_owned().into();
            //let ext =".png";
            stem.push(".png");
            let mut tables_folder:OsString = Some(&config.tables_folder).unwrap().into();
//            tables_folder = tables_folder;
            tables_folder.push("/Wheels/");
            tables_folder.push(&stem);
                
            if Path::new(&tables_folder).exists() {println!("{:?}", &stem);}

            counter += 1;
            };
*/




   // let command = build_command();
   // let matches = command.get_matches_from(wild::args());
   // let dir_path = matches
   // .get_one::<String>("DIRPATH")
   // .map(|s| s.as_str())
   // .unwrap_or_default();

//println!("aaaa: {:?}\n {:?}",info.path, dir_path);
        /*
        main_selection_opt = Select::with_theme(&ColorfulTheme::default())
            .with_prompt("Select a table")
            .default(main_selection_opt.unwrap_or(0))
            .items(&selections[..])
            .interact_opt()
            .unwrap();

        match main_selection_opt {
            Some(selection) => {
                // search

                match selection {
                    SEARCH_INDEX => {
                        // show a fuzzy search
                        let selected = FuzzySelect::with_theme(&ColorfulTheme::default())
                            .with_prompt("Search a table:")
                            .items(&tables)
                            .interact_opt()
                            .unwrap();

                        if let Some(selected_index) = selected {
                            let info = vpx_files_with_tableinfo
                                .get(selected_index)
                                .unwrap()
                                .clone();
                            let info_str = display_table_line_full(&info, roms);
                            table_menu(
                                config,
                                &mut vpx_files_with_tableinfo,
                                vpinball_executable,
                                &info,
                                &info_str,
                            );
                        }
                    }
                    RECENT_INDEX => {
                        // take the last 10 most recent tables
                        let mut recent: Vec<IndexedTable> = vpx_files_with_tableinfo.clone();
                        recent.sort_by_key(|indexed| indexed.last_modified);
                        let last_modified = recent.iter().rev().take(50).collect::<Vec<_>>();
                        let last_modified_str: Vec<String> = last_modified
                            .iter()
                            .map(|indexed| display_table_line_full(indexed, roms))
                            .collect();

                        let selected = Select::with_theme(&ColorfulTheme::default())
                            .with_prompt("Select a table")
                            .items(&last_modified_str)
                            .default(0)
                            .interact_opt()
                            .unwrap();

                        if let Some(selected_index) = selected {
                            let info = last_modified.get(selected_index).unwrap();
                            let info_str = display_table_line_full(info, roms);
                            table_menu(
                                config,
                                &mut vpx_files_with_tableinfo,
                                vpinball_executable,
                                info,
                                &info_str,
                            );
                        }
                    }
                    _ => {
                        let index = selection - 2;

                        let info = vpx_files_with_tableinfo.get(index).unwrap().clone();
                        let info_str = display_table_line_full(&info, roms);
                        table_menu(
                            config,
                            &mut vpx_files_with_tableinfo,
                            vpinball_executable,
                            &info,
                            &info_str,
                        );
                    }
                }
            }
            None => break,
        };
    } */
}

fn setup(mut commands: Commands, asset_server: Res<AssetServer>, window: Query<&Window>) {
    // UI camera
   
    //commands.spawn(AnimatedImageBundle {
        //animated_image: asset_server.load("/usr/tables/Media/Time-Lord-3-Wheel.apng"),
        
        let window_width = window.single().width() / 2.0;

        for (i, (kind, file)) in [(Image::Webp, "/usr/tables/Media/giphy.webp")]
            .into_iter()
            .enumerate()
        {
            commands.spawn((
                AnimatedImageBundle {
                    animated_image: asset_server.load(file),
                    transform: Transform::from_xyz(
                        -window_width * ((-1.0 as f32).powi(i as i32)) / 2.0,
                      //  -75.0,
                        00.0,
                        0.0,
                    ),
                    ..default()
                },
                kind,
            )
            
        );
        
            commands
                .spawn(NodeBundle {
                    style: Style {
                        width: Val::Percent(25.0),
                        height: Val::Percent(50.0),
                        top: Val::Percent(10.0),
                        left: Val::Percent(50.0 * (i as f32)),
                        align_items: AlignItems::Start,
                        justify_content: JustifyContent::Center,
                        ..default()
                    },
                    ..default()
                })
                .with_children(|parent| {
                    parent.spawn((
                        TextBundle::from_sections(vec![
                            TextSection {
                                value: format!("{}\n", kind),
                                style: TextStyle {
                                    font_size: 60.0,
                                    ..default()
                                },
                            },
                            TextSection {
                                value: "play count: ".to_string(),
                                style: TextStyle {
                                    font_size: 50.0,
                                    ..default()
                                },
                            },
                            TextSection {
                                value: "0".to_string(),
                                style: TextStyle {
                                    font_size: 50.0,
                                    ..default()
                                },
                            },
                            TextSection {
                                value: "\ncurrent frame: ".to_string(),
                                style: TextStyle {
                                    font_size: 30.0,
                                    ..default()
                                },
                            },
                            TextSection {
                                value: "0".to_string(),
                                style: TextStyle {
                                    font_size: 30.0,
                                    ..default()
                                },
                            },
                            TextSection {
                                value: " / ".to_string(),
                                style: TextStyle {
                                    font_size: 30.0,
                                    ..default()
                                },
                            },
                            TextSection {
                                value: "0".to_string(),
                                style: TextStyle {
                                    font_size: 30.0,
                                    ..default()
                                },
                            },
                        ]),
                        kind,
                    ));
                });
                println!("{:?}",file);
        
        }

        fn log_updates(
            mut texts: Query<(&mut Text, &Image)>,
            playing_images: Query<(Ref<AnimatedImageController>, &Image)>,
        ) {
            for (animated_image, image_kind) in &playing_images {
                if animated_image.is_changed() {
                    for (mut text, text_kind) in &mut texts {
                        if image_kind != text_kind {
                            continue;
                        }
                        text.sections[2].value = format!("{}", animated_image.play_count());
                        text.sections[4].value = format!("{:>4}", animated_image.current_frame());
                        text.sections[6].value = format!("{}", animated_image.frame_count() as i32 - 1);
                    }
                }
            }
            // let gif = gif.single();
        }
        
        fn reset(
            keyboard_input: Res<ButtonInput<KeyCode>>,
            mut playing_images: Query<&mut AnimatedImageController>,
        ) {
            if keyboard_input.just_pressed(KeyCode::Space) {
                for mut animated_image in &mut playing_images {
                    animated_image.reset();
                }
            }
        }

    commands.spawn(Camera2dBundle::default());
    // Text with one section
    commands.spawn((
        // Create a TextBundle that has a Text with a single section.
        TextBundle::from_section(
            // Accepts a `String` or any type that converts into a `String`, such as `&str`
            "hello\nbevy!",
            TextStyle {
                // This font is loaded and will be used instead of the default font.
                font: asset_server.load("fonts/FiraSans-Bold.ttf"),
                font_size: 100.0,
                ..default()
            },
        ) // Set the justification of the Text
        .with_text_justify(JustifyText::Center)
        // Set the style of the TextBundle itself.
        .with_style(Style {
            position_type: PositionType::Absolute,
            bottom: Val::Px(5.0),
            right: Val::Px(5.0),
            ..default()
        }),
        ColorText,
    ));
    commands
    .spawn(NodeBundle {
        style: Style {
            flex_direction: FlexDirection::Column,
            align_self: AlignSelf::Stretch,
            height: Val::Percent(50.),
            overflow: Overflow::clip_y(),
            ..default()
        },
        background_color: Color::srgb(0.10, 0.10, 0.10).into(),
        ..default()
    })
    .with_children(|commands| {
        // Moving panel
        commands
            .spawn((
                NodeBundle {
                    style: Style {
                        flex_direction: FlexDirection::Column,
                        align_items: AlignItems::Center,
                        ..default()
                    },
                    ..default()
                },
                ScrollingList::default(),
                AccessibilityNode(NodeBuilder::new(Role::List)),
            ))
            .with_children(|commands| {
                // List items
                for i in 0..30 {
                    commands.spawn((
                        TextBundle::from_section(
                            format!("Item {i}"),
                            TextStyle {
                                font: asset_server
                                    .load("fonts/FiraSans-Bold.ttf"),
                                ..default()
                            },
                        ),
                        Label,
                        AccessibilityNode(NodeBuilder::new(Role::ListItem)),
                    ));
                }
            });
    });
}
    // Text with multiple sections
    

    #[cfg(not(feature = "default_font"))]
    
fn text_color_system(time: Res<Time>, mut query: Query<&mut Text, With<ColorText>>) {
    for mut text in &mut query {
        let seconds = time.elapsed_seconds();

        // Update the color of the first and only section.
        text.sections[0].style.color = Color::srgb(
            (1.25 * seconds).sin() / 2.0 + 0.5,
            (0.75 * seconds).sin() / 2.0 + 0.5,
            (0.50 * seconds).sin() / 2.0 + 0.5,
        );
    }
}


fn text_update_system(
    diagnostics: Res<DiagnosticsStore>,
    mut query: Query<&mut Text, With<FpsText>>,
) {
    for mut text in &mut query {
        if let Some(fps) = diagnostics.get(&FrameTimeDiagnosticsPlugin::FPS) {
            if let Some(value) = fps.smoothed() {
                // Update the value of the second section
                text.sections[1].value = format!("{value:.2}");
            }
        }
    }
}

fn table_menu(
    config: &ResolvedConfig,
    vpx_files_with_tableinfo: &mut Vec<IndexedTable>,
    vpinball_executable: &Path,
    info: &IndexedTable,
    info_str: &str,
) {
    let selected_path = &info.path;
    match choose_table_option(info_str) {
        Some(TableOption::Launch) => {
            launch(selected_path, vpinball_executable, None);
        }
        Some(TableOption::LaunchFullscreen) => {
            launch(selected_path, vpinball_executable, Some(true));
        }
        Some(TableOption::LaunchWindowed) => {
            launch(selected_path, vpinball_executable, Some(false));
        }
        Some(TableOption::ForceReload) => {
            match frontend_index(config, true, vec![selected_path.clone()]) {
                Ok(index) => {
                    vpx_files_with_tableinfo.clear();
                    vpx_files_with_tableinfo.extend(index);
                }
                Err(err) => {
                    let msg = format!("Unable to reload tables: {:?}", err);
                    prompt(msg.truecolor(255, 125, 0).to_string());
                }
            }
        }
        Some(TableOption::EditVBS) => {
            let path = vbs_path_for(selected_path);
            let result = if path.exists() {
                open_editor(&path, Some(config))
            } else {
                extractvbs(selected_path, false, None);
                open_editor(&path, Some(config))
            };
            match result {
                Ok(_) => {
                    println!("Launched editor for {}", path.display());
                }
                Err(err) => {
                    let msg = format!("Unable to edit VBS: {}", err);
                    prompt(msg.truecolor(255, 125, 0).to_string());
                }
            }
        }
        Some(TableOption::ExtractVBS) => match extractvbs(selected_path, false, None) {
            ExtractResult::Extracted(path) => {
                prompt(format!("VBS extracted to {}", path.to_string_lossy()));
            }
            ExtractResult::Existed(path) => {
                let msg = format!("VBS already exists at {}", path.to_string_lossy());
                prompt(msg.truecolor(255, 125, 0).to_string());
            }
        },
        Some(TableOption::ShowVBSDiff) => match script_diff(selected_path) {
            Ok(diff) => {
                prompt(diff);
            }
            Err(err) => {
                let msg = format!("Unable to diff VBS: {}", err);
                prompt(msg.truecolor(255, 125, 0).to_string());
            }
        },
        Some(TableOption::PatchVBS) => {
            let vbs_path = match extractvbs(selected_path, false, Some("vbs")) {
                ExtractResult::Existed(path) => path,
                ExtractResult::Extracted(path) => path,
            };
            match patch_vbs_file(&vbs_path) {
                Ok(applied) => {
                    if applied.is_empty() {
                        prompt("No patches applied.".to_string());
                    } else {
                        applied.iter().for_each(|patch| {
                            println!("Applied patch: {}", patch);
                        });
                        prompt(format!(
                            "Patched VBS file at {}",
                            vbs_path.to_string_lossy()
                        ));
                    }
                }
                Err(err) => {
                    let msg = format!("Unable to patch VBS: {}", err);
                    prompt(msg.truecolor(255, 125, 0).to_string());
                }
            }
        }
        Some(TableOption::UnifyLineEndings) => {
            let vbs_path = match extractvbs(selected_path, false, Some("vbs")) {
                ExtractResult::Existed(path) => path,
                ExtractResult::Extracted(path) => path,
            };
            match unify_line_endings_vbs_file(&vbs_path) {
                Ok(NoChanges) => {
                    prompt("No changes applied as file has correct line endings".to_string());
                }
                Ok(Unified) => {
                    prompt(format!(
                        "Unified line endings in VBS file at {}",
                        vbs_path.to_string_lossy()
                    ));
                }
                Err(err) => {
                    let msg = format!("Unable to patch VBS: {}", err);
                    prompt(msg.truecolor(255, 125, 0).to_string());
                }
            }
        }
        Some(TableOption::CreateVBSPatch) => {
            let original_path = match extractvbs(selected_path, true, Some("vbs.original")) {
                ExtractResult::Existed(path) => path,
                ExtractResult::Extracted(path) => path,
            };
            let vbs_path = vbs_path_for(selected_path);
            let patch_path = vbs_path.with_extension("vbs.patch");

            match run_diff(&original_path, &vbs_path, DiffColor::Never) {
                Ok(diff) => {
                    let mut file = File::create(patch_path).unwrap();
                    file.write_all(&diff).unwrap();
                }
                Err(err) => {
                    let msg = format!("Unable to diff VBS: {}", err);
                    prompt(msg.truecolor(255, 125, 0).to_string());
                }
            }
        }
        Some(TableOption::InfoShow) => match info_gather(selected_path) {
            Ok(info) => {
                prompt(info);
            }
            Err(err) => {
                let msg = format!("Unable to gather table info: {}", err);
                prompt(msg.truecolor(255, 125, 0).to_string());
            }
        },
        Some(TableOption::InfoEdit) => match info_edit(selected_path, Some(config)) {
            Ok(path) => {
                println!("Launched editor for {}", path.display());
            }
            Err(err) => {
                let msg = format!("Unable to edit table info: {}", err);
                prompt(msg.truecolor(255, 125, 0).to_string());
            }
        },
        Some(TableOption::InfoDiff) => match info_diff(selected_path) {
            Ok(diff) => {
                prompt(diff);
            }
            Err(err) => {
                let msg = format!("Unable to diff info: {}", err);
                prompt(msg.truecolor(255, 125, 0).to_string());
            }
        },
        None => (),
    }
}

fn prompt<S: Into<String>>(msg: S) {
    Input::<String>::new()
        .with_prompt(format!("{} - Press enter to continue.", msg.into()))
        .default("".to_string())
        .show_default(false)
        .interact()
        .unwrap();
}

fn choose_table_option(table_name: &str) -> Option<TableOption> {
    // iterate over table options
    let selections = TableOption::ALL
        .iter()
        .map(|option| option.display())
        .collect::<Vec<String>>();

    let selection_opt = Select::with_theme(&ColorfulTheme::default())
        .with_prompt(table_name)
        .default(0)
        .items(&selections[..])
        .interact_opt()
        .unwrap();

    selection_opt.and_then(TableOption::from_index)
}

fn launch(selected_path: &PathBuf, vpinball_executable: &Path, fullscreen: Option<bool>) {
    println!("{} {}", LAUNCH, selected_path.display());

    if !vpinball_executable.is_executable() {
        report_and_exit(format!(
            "Unable to launch table, {} is not executable",
            vpinball_executable.display()
        ));
    }

    match launch_table(selected_path, vpinball_executable, fullscreen) {
        Ok(status) => match status.code() {
            Some(0) => {
                //println!("Table exited normally");
            }
            Some(11) => {
                prompt(format!("{} Visual Pinball exited with segfault, you might want to report this to the vpinball team.", CRASH));
            }
            Some(139) => {
                prompt(format!("{} Visual Pinball exited with segfault, you might want to report this to the vpinball team.", CRASH));
            }
            Some(code) => {
                prompt(format!(
                    "{} Visual Pinball exited with code {}",
                    CRASH, code
                ));
            }
            None => {
                prompt("Visual Pinball exited with unknown code");
            }
        },
        Err(e) => {
            if e.kind() == std::io::ErrorKind::NotFound {
                report_and_exit(format!(
                    "Unable to launch table, vpinball executable not found at {}",
                    vpinball_executable.display()
                ));
            } else {
                report_and_exit(format!("Unable to launch table: {:?}", e));
            }
        }
    }
}

fn report_and_exit(msg: String) -> ! {
    eprintln!("{CRASH} {}", msg);
    exit(1);
}

fn launch_table(
    selected_path: &PathBuf,
    vpinball_executable: &Path,
    fullscreen: Option<bool>,
) -> io::Result<ExitStatus> {
    // start process ./VPinballX_GL -play [table path]
    let mut cmd = std::process::Command::new(vpinball_executable);
    match fullscreen {
        Some(true) => {
            cmd.arg("-EnableTrueFullscreen");
        }
        Some(false) => {
            cmd.arg("-DisableTrueFullscreen");
        }
        None => (),
    }
    cmd.arg("-play");
    cmd.arg(selected_path);
    let mut child = cmd.spawn()?;
    let result = child.wait()?;
    Ok(result)
}

fn display_table_line(table: &IndexedTable) -> String {
    let file_name = table
        .path
        .file_stem()
        .unwrap()
        .to_str()
        .unwrap()
        .to_string();
    Some(table.table_info.table_name.to_owned())
        .filter(|s| !s.clone().unwrap_or_default().is_empty())
        .map(|s| {
            format!(
                "{} {}",
                capitalize_first_letter(s.unwrap_or_default().as_str()),
                (format!("({})", file_name)).dimmed()
            )
        })
        .unwrap_or(file_name)
}

fn display_table_line_full(table: &IndexedTable, roms: &HashSet<String>) -> String {
    let base = display_table_line(table);
    let gamename_suffix = match &table.game_name {
        Some(name) => {
            let rom_found = table.local_rom_path.is_some() || roms.contains(&name.to_lowercase());
            if rom_found {
                format!(" - [{}]", name.dimmed())
            } else if table.requires_pinmame {
                format!(" - {} [{}]", Emoji("âš ï¸", "!"), &name)
                    .yellow()
                    .to_string()
            } else {
                format!(" - [{}]", name.dimmed())
            }
        }
        None => "".to_string(),
    };
    let b2s_suffix = match &table.b2s_path {
        Some(_) => " â–€".dimmed(),
        None => "".into(),
    };
    format!("{}{}{}", base, gamename_suffix, b2s_suffix)
}

fn capitalize_first_letter(s: &str) -> String {
    s[0..1].to_uppercase() + &s[1..]
}
